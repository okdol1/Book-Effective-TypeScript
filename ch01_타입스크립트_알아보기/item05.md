## 요약
- any 타입을 사용하면 타입 체커와 타입스크립트 언어 서비스를 무력화시켜버립니다.<br>
any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어뜨립니다. 최대한 사용을 피하도록 합시다.

### any 타입 지양하기
타입 선언을 추가하는 데에 시간을 쏟고 싶지 않아서 any 타입이나 타입 단언문 (as any)을 사용하고 싶기도 할 것이다.

일부 특별한 경우를 제외하고는 any를 사용하면 타입스크립트의 수많은 장점을 누릴 수 없게된다.

부득이하게 any를 사용하더라도 그 위험성을 알고 있어야 한다.

### any 타입에는 타입 안정성이 없다.
- any 타입을 사용하면 타입 체커에게 타입 체킹을 하지말라는 것과 같아 타입 안정성을 보장받지 못하게 된다.

### any는 함수 시그니처를 무시한다.
- 함수를 작성할 때는 시그니처를 명시해야 한다.<br>
호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다.<br>
그러나 any 타입을 사용하면 이러한 약속을 무시하게 된다

### any 타입에는 언어 서비스가 제공되질 않는다.
- any 타입을 사용하면 타입스크립트 경험의 핵심 요소인 언어 서비스를 누리지 못하기 때문에 생산성이 저하된다.
- ex: 자동완성 기능, 적절한 도움말 등

### any 타입은 버그를 감춘다.
- 예를 들어 any를 매개변수로 받게되는 함수 내에서 id 를 사용할 때 id 가 없는 값을 인자로 준다면 타입 체커에서는 에러가 발생하지 않지만, <br>런타임에서는 에러가 발생하게 된다. <br>구체적인 타입을 사용한다면 타입 체커가 오류를 발견 했을것이다.

### any는 타입 설계를 감춘다.
- any 타입을 사용하면 타입 설계가 불분명해진다. <br>객체를 정의할 때 특히 문제가 된다. <br>설계가 명확히 보이도록 타입을 일일이 작성하는 것이 좋다.

### any는 타입시스템의 신뢰도를 떨어뜨린다.
- 런타임에서 타입 오류를 발견하게 된다면 타입 체커를 신뢰할 수 없다.
- 구체적인 타입을 지정하면 러타임에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높일 수 있다.
- 하지만 어쩔 수 없이 any를 써야하는 상황도 있을 수 있다.