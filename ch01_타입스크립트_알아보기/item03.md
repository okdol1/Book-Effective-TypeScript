# 코드 생성과 타입이 관계없음을 이해하기
큰 그림에서 보면, 타입스크립트 컴파일러는 두 가지 역할을 수행합니다.
- 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일합니다.
- 코드의 타입 오류를 체크합니다.

여기서 놀라운 점은 이 두 가지가 서로 완벽히 독립적이라는 것입니다.

다시 말해서, 타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않습니다. 또한 그 자바스크립트의 실행 시점에도 타입은 영향을 미치지 않습니다.

## 요약
- 코드 생성은 타입 시스템과 무관합니다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않습니다.
- 타입 오류가 존재하더라도 코드 생성(컴파일)은 가능합니다.
- 타입스크립트 타입은 런타임에 사용할 수 없습니다. 런타임에 타입을 지정하려면, 타입 정보 유지를 위한 별도의 방법이 필요합니다. 일반적으로는 태그된 유니온과 속성 체크 방법을 사용합니다. 또는 클래스 같이 타입스크립트 타입과 런타임 값, 둘 다 제공하는 방법이 있습니다.

### 타입 오류가 있는 코드도 컴파일이 가능합니다
- 컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능합니다.
- 만약 오류가 있을 때 컴파일하지 않으려면, tsconfig.json에 noEmitOnError를 설정하거나 빌드 도구에 동일하게 적용하면 됩니다.

### 런타임에는 타입 체크가 불가능합니다
- 타입스크립트의 타입은 '제거 가능(erasable)'합니다. 실제로 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버립니다.
- 타입을 명확하게 하려면, 런타임에 타입 정보를 유지하는 방법이 필요합니다.
  - 속성이 존재하는지 체크(조건문)
  - 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 '태그' 기법
  - 타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘 다 사용하는 기법 -> 타입을 클래스로 만들기
  - 인터페이스는 타입으로만 사용 가능하지만, 클래스로 선언하면 타입과 값으로 모두 사용할 수 있으므로 오류가 없습니다

### 타입 연산은 런타임에 영향을 주지 않습니다
- as는 타입 연산이고 런타임 동작에는 아무런 영향을 미치지 않습니다.
- 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 자바스크립트 연산을 통해 변환을 수행해야 합니다.

### 런타임 타입은 선언된 타입과 다를 수 있습니다
- 타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있습니다. 타입이 달라지는 혼란스러운 상황을 가능한 한 피해야 합니다. 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 합니다.

### 타입스크립트 타입으로는 함수를 오버로드할 수 없습니다
- 오버로드란 ?
  - C++ 같은 언어는 동일한 이름에 매개변수만 다른 여러 버전의 함수를 허용하는데 이를 '함수 오버로딩'이라고 합니다
- 타입스크립트에서는 타입과 런타임의 동작이 무관하기 때문에, 함수 오버로딩은 불가능합니다
- 타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 온전히 타입 수준에서만 동작합니다. 하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만, 구현체(implementation)는 오직 하나뿐입니다

### 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다
- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에, 런타임의 성능에 아무런 영향을 주지 않습니다.